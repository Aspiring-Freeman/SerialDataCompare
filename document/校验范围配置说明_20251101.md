# 校验范围配置说明

**日期**: 2025-11-01  
**版本**: v1.2.0补充  

---

## 问题

用户导入工业协议后，数据校验失败。原因是校验范围配置不正确。

## 原始配置

```json
"checksum_config": {
  "checksum_type": "累加和",
  "position": "帧尾前",
  "start_offset": 0,
  "end_offset": 80,
  "checksum_length": 1
}
```

**问题**: 
- `start_offset: 0` 表示从帧头后第0个字节开始（不包含帧头）
- 但该协议的校验范围需要包含帧头

## 正确配置

```json
"checksum_config": {
  "checksum_type": "累加和",
  "position": "帧尾前",
  "start_offset": -1,
  "end_offset": -2,
  "checksum_length": 1
}
```

**说明**:
- `start_offset: -1` - 包含帧头（从索引0开始）
- `end_offset: -2` - 到校验码前（不包含校验码和帧尾）

## 参数详解

### start_offset (校验起始位置)

| 值 | 含义 | 说明 |
|----|------|------|
| `-1` | 包含帧头 | 从索引0开始（帧头） |
| `0` | 帧头后第一个字节 | 从索引1开始（跳过帧头） |
| `1` | 帧头后第二个字节 | 从索引2开始（跳过帧头和第一个字节） |
| `N` | 帧头后第N+1个字节 | 从索引N+1开始 |

### end_offset (校验结束位置)

| 值 | 含义 | 说明 |
|----|------|------|
| `-1` | 到帧尾前 | 不包含帧尾，但包含校验码 |
| `-2` | 到校验码前 | 不包含校验码和帧尾（最常用） |
| `-3` | 到校验码前2个字节 | 不包含最后3个字节 |
| `N` (正数) | 到索引N | 到指定的绝对索引位置（不包含） |

## 测试示例

### 数据帧结构

```
索引: 0   1   2   3   ...  80  81  82
数据: 68  AD  53  00  ...  19  E0  16
     ↑                    ↑   ↑   ↑
    帧头                 数据 校验 帧尾
```

### 校验计算

配置: `start_offset=-1`, `end_offset=-2`

```
校验范围: 索引0到索引80（共81个字节）
         = 68 AD 53 00 ... 19
         
累加和计算: (68 + AD + 53 + ... + 19) & 0xFF = E0 ✅
实际校验码: 索引81 = E0 ✅
匹配成功！
```

## 常见配置场景

### 场景1: 不包含帧头，到校验码前（最常见）

```json
{
  "start_offset": 0,
  "end_offset": -2
}
```

**适用**: 大多数标准协议（如Modbus）

### 场景2: 包含帧头，到校验码前

```json
{
  "start_offset": -1,
  "end_offset": -2
}
```

**适用**: 工业设备协议，需要校验整个数据包

### 场景3: 指定固定范围

```json
{
  "start_offset": 0,
  "end_offset": 50
}
```

**适用**: 固定长度协议，只校验前N个字节

### 场景4: 包含校验码本身

```json
{
  "start_offset": 0,
  "end_offset": -1
}
```

**适用**: 特殊协议，校验码参与校验计算

## 调试方法

### 方法1: 使用Python脚本测试

```python
data_hex = '68 AD 53 ...'
data = bytes.fromhex(data_hex.replace(' ', ''))

# 尝试不同范围
checksum1 = sum(data[0:-2]) & 0xFF  # 包含帧头，到校验码前
checksum2 = sum(data[1:-2]) & 0xFF  # 不包含帧头，到校验码前

print(f'包含帧头: {checksum1:02X}')
print(f'不包含帧头: {checksum2:02X}')
print(f'实际校验码: {data[-2]:02X}')
```

### 方法2: 查看协议文档

1. 确认校验算法（累加和/XOR/CRC）
2. 确认校验范围（从哪到哪）
3. 确认是否包含帧头
4. 确认校验码位置

### 方法3: 使用实际数据验证

1. 获取已知正确的数据帧
2. 手动计算校验码
3. 对比各种配置的结果
4. 找到匹配的配置

## 代码修改

### 修改位置

`core/checksum.py` - `ChecksumValidator.validate_frame()`

### 关键修改

```python
# 支持 start_offset=-1 来包含帧头
if start_offset == -1:
    data_start = 0  # 从帧头开始
else:
    data_start = 1 + start_offset  # 从帧头后开始

# 支持多种 end_offset 模式
if end_offset == -2:
    data_end = checksum_start  # 到校验码前
elif end_offset == -1:
    data_end = len(frame_data) - 1  # 到帧尾前
elif end_offset < 0:
    data_end = len(frame_data) + end_offset  # 负数索引
else:
    data_end = end_offset  # 绝对索引
```

## 注意事项

1. **索引从0开始**: 帧头在索引0，第一个数据字节在索引1
2. **end_offset不包含**: `end_offset=81` 表示到索引81（不包含81）
3. **校验码位置**: 通常在`len(data) - 2`（帧尾前1个字节）
4. **小端序**: 多字节校验码通常使用小端序
5. **测试验证**: 修改配置后务必用实际数据测试

---

## 修正后的协议文件

已创建: `protocol_industrial_fixed.json`

包含正确的校验配置，可直接使用。

---

**更新时间**: 2025-11-01  
**相关文件**: 
- `core/checksum.py` - 修改校验逻辑
- `protocol_industrial_fixed.json` - 修正后的协议
